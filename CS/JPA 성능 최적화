JPA 성능 최적화 -> API스팩은 최소한으로 잡기, 불필요한 API스팩을 노출시키면 성능 저하 및 여러 문제가 일어난다. 대부분의 JPA성능 문제는 90%이상이 패치 조인으로 해결가능하다.
-> 간단한건 EntityGraph를 사용, 조금 복잡하면 JPQL로 패치 조인
 **쿼리 방식 선택 권장 순서**
1. 우선 엔티티를 DTO로 변환하는 방법을 선택한다. 
2.필요하면 페치 조인(Jpa에만 있는 기능)으로 성능을 최적화 한다. 대부분의 성능 이슈가 해결된다. -> XToOne 관계(row의 개수를 증가시키지 않음)인 부분만 적용하기!!! 중요 -> 
3.그래도 안되면 DTO로 직접 조회하는 방법을 사용한다. 
4.최후의 방법은 JPA가 제공하는 네이티브 SQL이나 스프링 JDBC Template을 사용해서 SQL을 직접 사용한다.  
일대다 상황에서는 조인한 테이블의 만큼 쿼리 발생함 -> order(일) 에서orderItems(다)조회하면 leftjoin되는데 orderItems만큼 쿼리가 나가게됨. -> JPA의 distinct는 sql에 distinct를 추가하고 중복된 조회는 하지 않음
-> 단점: 컬렉션 페치조인은 페이징 불가능! -> 할 수는 있지만 메모리에서 페이징을 해버린다!(매우 위험함)
——————————————————
일대다 상황속에서 페이징과 성능 최적화 해결법!
X대일 까지는 모두 패치조인 걸고 일대다 일때 yml에 (default_batch_fetch_size = x  IN쿼리 개수) 사용! -> 개별 설정은 @BatchSize 어노테이션으로도 사용가능. OneToMany필드에 붙이기 
-> `default_batch_fetch_size` 의 크기는 적당한 사이즈를 골라야 하는데, 100~1000 사이를 선택하는 것을 권장한다. 이 전략을 SQL IN 절을 사용하는데, 데이터베이스에 따라 IN 절 파라미터를 1000으로 제한하기 도 한다. 1000으로 잡으면 한번에 1000개를 DB에서 애플리케이션에 불러오므로 DB에 순간 부하가 증가할 수 있다. 하지만 애플리케이션은 100이든 1000이든 결국 전체 데이터를 로딩해야 하므로 메모리 사용량이 같다. 1000으로 설정하는 것이 성능상 가장 좋지만, 결국 DB든 애플리케이션이든 순간 부하를 어디까지 견딜 수 있는 지로 결정하면 된다.

API 개발 순서
1. 엔티티를 DTO로 조회 -> 페치 조인으로 퀴리 수를 최적화
2. 컬렉션 최적화 -> 페이징 필요하면 batchSize로 최적화 
                1. 페이징 X-> 페치 조인 사용
3. 엔티티 조회 방식으로 해결 안되면 DTO 조회 방식 사용
4. DTO로 안되면 NativeSQL or 스프링 JdbcTemplates

OSIV *** -> 결론: 코드 적으로는 키는게 훨씬 유지 보수가 쉽겠지만, 코드를 짤 때 서비스 계층을 사용하고 그 안에서 레이지 로딩을 다 가져가기 때문에 OSIV를 항상 꺼놓고 성능을 챙기자.

<img width="962" alt="OSIV ON" src="https://github.com/sangjin6439/TIL/assets/62700860/ffd017a0-a1d8-4f1e-8ef1-51d3ef661c47">

`spring.jpa.open-in-view` : true 기본값
이 기본값을 뿌리면서 애플리케이션 시작 시점에 warn 로그를 남기는 것은 이유가 있다. OSIV 전략은 트랜잭션 시작처럼 최초 데이터베이스 커넥션 시작 시점부터 API 응답이 끝날 때 까지 영속성 컨텍스트 와 데이터베이스 커넥션을 유지한다. 그래서 지금까지 View Template이나 API 컨트롤러에서 지연 로딩이 가능했던 것이다. 지연 로딩은 영속성 컨텍스트가 살아있어야 가능하고, 영속성 컨텍스트는 기본적으로 데이터베이스 커넥션을 유지한다. 이것 자체가 큰 장점이다.

단점-> 이 전략은 너무 오랜시간 데이터베이스 커넥션 리소스를 사용함 -> 실시간 트래픽이 중요한 애플리케이션에서는 커넥션이 모자랄 수 있다. -> 서버 장애로 이어짐
`spring.jpa.open-in-view` : false
해결 -> OSIV 종료. OSIV를 끄면 트랜잭션을 종료할 때  영속성 컨텍스트를 닫고, 데이터베이스 커넥션도 반환함. 리소스 낭비하지 않는다.  단점->OSIV를 끄면 모든 지연로딩을 트랜잭션 안에서 처리해야 함. ->
지금까지 작성한 많은 지연 로딩 코드를 트랜잭션 안으로 넣어야하는 단점이 있다. 트랜잭션이 끝나기 전에 지연 로딩을 강제로 호출해 두어야 함. 
==> 해결법!! Service계층의 트렌젝션 범위 내에서 레이지 로딩을 끝내면 됨. 
